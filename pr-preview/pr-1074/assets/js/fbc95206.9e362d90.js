"use strict";(self.webpackChunkpush_website=self.webpackChunkpush_website||[]).push([[10716],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(296540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},213050:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var s=t(474848),a=t(28453);const i={id:"docs-chain-tutorial-build-chat",title:"Build Cross-Chain Chat",hide_title:!0,slug:"./build-chat",displayed_sidebar:"pushChainSidebar",sidebar_position:1,image:"/assets/docs/previews/docs_chain_tutorial_build_chat--build_cross-chain_chat.png"},r="Build a Cross-Chain Chat Application",o={id:"chain/tutorials/docs-chain-tutorial-build-chat",title:"Build Cross-Chain Chat",description:"If you\u2019ve already seen our cross-chain email tutorial, you know the power of the Push Chain SDK for sending data securely across different blockchains. This time, let\u2019s apply the same underlying concepts to build a decentralized chat system, enabling quick, on-chain message exchanges between Ethereum and Solana users.",source:"@site/docs/chain/02-tutorials/02-Build-cross-chain-chat.mdx",sourceDirName:"chain/02-tutorials",slug:"/chain/tutorials/build-chat",permalink:"/push-website/pr-preview/pr-1074/docs/chain/tutorials/build-chat",draft:!1,unlisted:!1,editUrl:"https://github.com/push-protocol/push-website/blob/main/docs/chain/02-tutorials/02-Build-cross-chain-chat.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"docs-chain-tutorial-build-chat",title:"Build Cross-Chain Chat",hide_title:!0,slug:"./build-chat",displayed_sidebar:"pushChainSidebar",sidebar_position:1,image:"/assets/docs/previews/docs_chain_tutorial_build_chat--build_cross-chain_chat.png"},sidebar:"pushChainSidebar",previous:{title:"Build Cross-Chain Email",permalink:"/push-website/pr-preview/pr-1074/docs/chain/tutorials/build-email"},next:{title:"Concepts",permalink:"/push-website/pr-preview/pr-1074/docs/chain/concepts"}},c={},h=[{value:"Step 1: Dependencies and Setup",id:"step-1-dependencies-and-setup",level:2},{value:"Step 2: Create Your Signer",id:"step-2-create-your-signer",level:2},{value:"Step 3: Initialize Push Chain",id:"step-3-initialize-push-chain",level:2},{value:"Step 4: Add Recipient",id:"step-4-add-recipient",level:2},{value:"Step 5: Compose a Chat Message",id:"step-5-compose-a-chat-message",level:2},{value:"Step 6: Send the Chat Data",id:"step-6-send-the-chat-data",level:2},{value:"Step 7: Fetch Chat History",id:"step-7-fetch-chat-history",level:2},{value:"Complete Example Code",id:"complete-example-code",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{Head:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"build-a-cross-chain-chat-application",children:"Build a Cross-Chain Chat Application"}),"\n",(0,s.jsxs)(n.p,{children:["If you\u2019ve already seen our cross-chain email tutorial, you know the power of the ",(0,s.jsx)(n.strong,{children:"Push Chain SDK"})," for sending data securely across different blockchains. This time, let\u2019s apply the same underlying concepts to build a decentralized chat system, enabling quick, on-chain message exchanges between Ethereum and Solana users."]}),"\n",(0,s.jsxs)(n.p,{children:["A chat interface is often more dynamic than an email-based approach. While email structures might imply a more formal flow, chats tend to be instantaneous and conversational. However, at a protocol level, sending a chat message is similar to sending an email: you\u2019re transmitting serialized data through a transaction. With ",(0,s.jsx)(n.strong,{children:"Push Chain"}),", you can harness the same transaction pattern\u2014just tweak the content to be a real-time conversation. Let\u2019s get started."]}),"\n",(0,s.jsx)(t,{children:(0,s.jsx)("title",{children:"Cross-Chain Chat | Tutorial | Push Chain | Push Documentation"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"step-1-dependencies-and-setup",children:"Step 1: Dependencies and Setup"}),"\n",(0,s.jsx)(n.p,{children:"You\u2019ll need to install (or already have) the following libraries in your project:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install @pushchain/devnet viem\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What\u2019s Included?"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@pushchain/devnet"}),": Gives you the methods for initializing, signing, and sending transactions over Push Chain."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"viem"}),": Helps manage private keys and produce signatures on Ethereum."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Import installed dependencies:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Import Push Chain SDK\nimport { PushChain, CONSTANTS, createUniversalSigner, createUniversalAccount } from '@pushchain/devnet';\n\n// Import utility functions from viem\nimport { hexToBytes } from 'viem';\nimport { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-2-create-your-signer",children:"Step 2: Create Your Signer"}),"\n",(0,s.jsx)(n.p,{children:"Before you can chat, you must authenticate yourself as the message sender. We\u2019ll use a private key for this example (though other signing methods are possible such as using the Push Wallet):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const privateKey = generatePrivateKey(); // Replace it with your private key generation logic\nconst account = privateKeyToAccount(privateKey);\n\n// Create Signer. Defaults to Ethereum Sepolia\nconst signer = createUniversalSigner({\n  address: account.address,\n  signMessage: async (data) =>\n    hexToBytes(await account.signMessage({ message: { raw: data } })),\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-3-initialize-push-chain",children:"Step 3: Initialize Push Chain"}),"\n",(0,s.jsx)(n.p,{children:"With your signer ready, initialize the Push Chain instance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const pushChain = await PushChain.initialize(signer);\n// devnet is default, but other environments can be specified\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-4-add-recipient",children:"Step 4: Add Recipient"}),"\n",(0,s.jsx)(n.p,{children:"Specify which accounts you want to chat with. Each recipient requires a chain name, ID and an address:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const recipients = [\n  createUniversalAccount({\n    chain: CONSTANTS.CHAIN.SOLANA,\n    chainId: CONSTANTS.CHAIN_ID.SOLANA.DEVNET,\n    address: 'ySYrGNLLJSK9hvGGpoxg8TzWfRe8ftBtDSMECtx2eJR',\n  }),\n];\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-5-compose-a-chat-message",children:"Step 5: Compose a Chat Message"}),"\n",(0,s.jsx)(n.p,{children:"Unlike emails, chat messages are typically shorter and more frequent. Let\u2019s wrap our text, sender info, and timestamp in JSON:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const chatMessage = {\n  sender: account.address,\n  text: 'Hello from Ethereum to Solana!',\n  timestamp: Date.now(),\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-6-send-the-chat-data",children:"Step 6: Send the Chat Data"}),"\n",(0,s.jsxs)(n.p,{children:["Push Chain transactions should be labeled with categories (e.g., ",(0,s.jsx)(n.code,{children:"CHAT_APP"}),") so you can differentiate them from other message types:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const tx = await pushChain.tx.send(recipients, {\n  category: 'CHAT_APP',\n  data: JSON.stringify(chatMessage),\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-7-fetch-chat-history",children:"Step 7: Fetch Chat History"}),"\n",(0,s.jsx)(n.p,{children:"To visualize previous messages, we\u2019ll decode them from a transaction response. Pass in the hash or a user address to retrieve transactions, then parse out the chat details:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const results = await pushChain.tx.get(tx.txHash);\nfor (const blocks of results.blocks) {\n  for (const t of blocks.transactions) {\n    console.log('email: ', t.data);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"complete-example-code",children:"Complete Example Code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Import Push Chain SDK\nimport { PushChain, CONSTANTS, createUniversalSigner, createUniversalAccount } from '@pushchain/devnet';\n\n// Import utility functions from viem\nimport { hexToBytes } from 'viem';\nimport { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';\n\n// Create Your Signer\nconst privateKey = generatePrivateKey(); // Replace it with your private key generation logic\nconst account = privateKeyToAccount(privateKey);\n\n// Create Signer. Defaults to Ethereum Sepolia\nconst signer = createUniversalSigner({\n  address: account.address,\n  signMessage: async (data) =>\n    hexToBytes(await account.signMessage({ message: { raw: data } })),\n});\n\n// Initialize Push Chain\nconst pushChain = await PushChain.initialize(signer);\n// devnet is default, but other environments can be specified\n\n// Add Recipient\nconst recipients = [\n  createUniversalAccount({\n    chain: CONSTANTS.CHAIN.SOLANA,\n    chainId: CONSTANTS.CHAIN_ID.SOLANA.DEVNET,\n    address: 'ySYrGNLLJSK9hvGGpoxg8TzWfRe8ftBtDSMECtx2eJR',\n  }),\n];\n\n// Compose a Chat Message\nconst chatMessage = {\n  sender: account.address,\n  text: 'Hello from Ethereum to Solana!',\n  timestamp: Date.now(),\n};\n\n// Send the Chat Data\nconst tx = await pushChain.tx.send(recipients, {\n  category: 'CHAT_APP',\n  data: JSON.stringify(chatMessage),\n});\n\n// Delay for 3 seconds\n\n// Fetch Chat History\nconst results = await pushChain.tx.get(tx.txHash);\nfor (const blocks of results.blocks) {\n  for (const t of blocks.transactions) {\n    console.log('email: ', t.data);\n  }\n}\n\n"})}),"\n",(0,s.jsx)(n.h1,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Creating a cross-chain chat experience reveals how flexible the Push Chain SDK can be. With just a few modifications to your code, you can switch from a \u201cmailbox\u201d format to a real-time messaging interface that works across multiple networks. Adapt this foundation to add channels for group chat, user profiles, or any custom messaging feature you envision. This is just one more example of how Push Chain opens doors to more fluid Web3 interactions."}),"\n",(0,s.jsx)(n.p,{children:"Experiment with new ideas, extend this chat to other blockchains, and bring your dApp users the power of borderless on-chain communication!"})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);